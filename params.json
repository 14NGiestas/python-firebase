{"name":"Python-firebase","tagline":"Python interface to the Firebase's REST API","body":"# Python Firebase\r\n\r\nPython interface to the Firebase's REST API\r\n\r\n## Installation\r\n\r\npython-firebase highly makes use of the **requests** library so before you start, you need to install that package.\r\n\r\n    $ sudo pip install requests==0.9.1\r\n    $ git clone git@github.com:ozgur/python-firebase.git\r\n    $ python setup.py install\r\n\r\n## Getting Started\r\n\r\nYou can fetch any of your data in JSON format by appending '.json' to the end of the URL in which your data resides and, then send an HTTPS request through your browser. Like all other REST specific APIs, Firebase offers a client to update(PATCH, PUT), create(POST), or remove(DELETE) his stored data along with just to fetch it.\r\n\r\nThe library provides all the correspoding methods for those actions in both synchoronous and asynchronous manner. You can just start an asynchronous GET request with your callback function, and the method\r\n\r\n\r\nTo fetch all the users in your storage simply do the following:\r\n\r\n```python\r\nfrom firebase import firebase\r\nfirebase = firebase.FirebaseApplication('https://your_storage.firebaseio.com', None)\r\nresult = firebase.get('/users', None)\r\nprint result\r\n{'1': 'John Doe', '2': 'Jane Doe'}\r\n```\r\n\r\n\r\nThe second argument of **get** method is the name of the snapshot. Thus, if you leave it NULL, you get the data in the URL **/users.json**. Besides, if you set it to **1**, you get the data in the url **/users/1.json**. In other words, you get the user whose ID equals to 1.\r\n\r\n```python\r\nfrom firebase import firebase\r\nfirebase = firebase.FirebaseApplication('https://your_storage.firebaseio.com', None)\r\nresult = firebase.get('/users', '1')\r\nprint result\r\n{'1': 'John Doe'}\r\n```\r\n\r\nYou can also provide extra query parameters that will be appended to the url or extra key-value pairs sent in the HTTP header.\r\n\r\n```python\r\nfrom firebase import firebase\r\nfirebase = firebase.FirebaseApplication('https://your_storage.firebaseio.com', None)\r\nresult = firebase.get('/users/2', None, {'print': 'pretty'}, {'X_FANCY_HEADER': 'VERY FANCY'})\r\nprint result\r\n{'2': 'Jane Doe'}\r\n```\r\n\r\nCreating new data requires a POST or PUT request. Assuming you don't append **print=silent** to the url, if you use POST the returning value becomes the name of the snapshot, if PUT you get the data you just sent. If print=silent is provided, you get just NULL because the backend never sends an output.\r\n\r\n```python\r\nfrom firebase import firebase\r\nfirebase = firebase.FirebaseApplication('https://your_storage.firebaseio.com', None)\r\nnew_user = 'Ozgur Vatansever'\r\n\r\nresult = firebase.post('/users', new_user, {'print': 'pretty'}, {'X_FANCY_HEADER': 'VERY FANCY'})\r\nprint result\r\n{'name': 'Jane Doe'}\r\n\r\nresult = firebase.post('/users', new_user, {'print': 'silent'}, {'X_FANCY_HEADER': 'VERY FANCY'})\r\nprint result == None\r\nTrue\r\n```\r\n\r\nDeleting data is relatively easy compared to other actions. You just set the url and that's all. Backend sends no output as a result of a delete operation.\r\n\r\n```python\r\nfrom firebase import firebase\r\nfirebase = firebase.FirebaseApplication('https://your_storage.firebaseio.com', None)\r\nfirebase.delete('/users', '1')\r\n# John Doe goes away.\r\n```\r\n\r\n## Authentication\r\n\r\nAuthentication in Firebase is nothing but to simply creating a token that conforms to the JWT standarts and, putting it into the querystring with the name **auth**. The library creates that token for you so you never end up struggling with constructing a valid token on your own. If the data has been protected against write/read operations with some security rules, the backend sends an appropriate error message back to the client with the status code **403 Forbidden**.\r\n\r\n```python\r\nfrom firebase import firebase\r\nfirebase = firebase.FirebaseApplication('https://your_storage.firebaseio.com', authentication=None)\r\nresult = firebase.get('/users', None, {'print': 'pretty'})\r\nprint result\r\n{'error': 'Permission denied.'}\r\n\r\nauthentication = firebase.Authentication('THIS_IS_MY_SECRET', 'ozgurvt@gmail.com', password=None)\r\nfirebase.authentication = authentication\r\nresult = firebase.get('/users', None, {'print': 'pretty'})\r\nprint result\r\n{'1': 'John Doe', '2': 'Jane Doe'}\r\n```\r\n\r\n## Concurrency\r\n\r\nThe interface heavily depends on the standart **multiprocessing** library when concurrency comes in. While creating an asynchronous call, an on-demand process pool is created and, the async method is executed by one the idle process inside the pool. When the method returns, the pool process ships the returning value back to the main process with the callback function provided.\r\n\r\n```python\r\nimport json\r\n\r\nfrom firebase import firebase\r\nfrom firebase import jsonutil\r\n\r\nfirebase = firebase.FirebaseApplication('https://your_storage.firebaseio.com', authentication=None)\r\n\r\ndef log_user(response):\r\n    with open('/tmp/users/%s.json' % response.keys()[0], 'w') as users_file:\r\n        users_file.write(json.dumps(response, cls=jsonutil.JSONEncoder))\r\n\r\nfirebase.get_async('/users', None, {'print': 'pretty'}, callback=log_user)\r\n```\r\n\r\n# TODO\r\n\r\n * FirebaseAuthentication class must accept additional auth parameters.\r\n * Async calls must deliver exceptions raised back to the main process.\r\n * More regression/stress tests on asynchronous calls.\r\n * Docs must be generated.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}